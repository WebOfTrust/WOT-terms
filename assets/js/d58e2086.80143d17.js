"use strict";(self.webpackChunkwot_terms_docusaurus=self.webpackChunkwot_terms_docusaurus||[]).push([[8600],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>f});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),d=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},h=function(e){var t=d(e.components);return i.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,h=r(e,["components","mdxType","originalType","parentName"]),c=d(n),p=a,f=c["".concat(l,".").concat(p)]||c[p]||u[p]||o;return n?i.createElement(f,s(s({ref:t},h),{},{components:n})):i.createElement(f,s({ref:t},h))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=p;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[c]="string"==typeof e?e:a,s[1]=r;for(var d=2;d<o;d++)s[d]=n[d];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},33783:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var i=n(87462),a=(n(67294),n(3905));const o={sidebar_position:1},s=void 0,r={unversionedId:"GLEIF/2022-02-07_vlei-q-a_v1.1-final",id:"GLEIF/2022-02-07_vlei-q-a_v1.1-final",title:"2022-02-07_vlei-q-a_v1.1-final",description:"vLEI Q&A",source:"@site/docs/GLEIF/2022-02-07_vlei-q-a_v1.1-final.md",sourceDirName:"GLEIF",slug:"/GLEIF/2022-02-07_vlei-q-a_v1.1-final",permalink:"/WOT-terms/docs/GLEIF/2022-02-07_vlei-q-a_v1.1-final",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"GLEIF",permalink:"/WOT-terms/docs/category/gleif"},next:{title:"2022-12-06_appendix-1-non-disclosure-agreement_v1.0_final",permalink:"/WOT-terms/docs/GLEIF/2022-12-06_appendix-1-non-disclosure-agreement_v1.0_final"}},l={},d=[{value:"vLEI Q&amp;A",id:"vlei-qa",level:2}],h={toc:d},c="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"vlei-qa"},"vLEI Q&A"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Public\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 2 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Questions and Answers regarding the verifiable LEI (vLEI)")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"How does the LEI fit into the digital world?")),(0,a.kt)("p",null,"The LEI and the Global LEI System (GLEIS) were envisioned from the start as a public-private\npartnership that should bring transparency and benefits to both the public and the private sectors.\nAnd although the LEI was used initially to identify legal entities in financial services, almost\nexclusively for regulatory reporting purposes, by no means is the need for identification of legal\nentities limited to activities in the financial services domain or for use exclusively in regulatory\nreporting."),(0,a.kt)("p",null,"Over the 6 years that the GLEIS has been in existence, there has been many an outreach and\nengagement to other industries and domains, promoting the LEI for its strengths to identify legal\nentities \u2013 international scope, based on a standard, a unique, persistent and permanent identifier,\noperating system under regulatory oversight, free from licensing for access and redistribution."),(0,a.kt)("p",null,"The Global Legal Entity Identifier Foundation (GLEIF) saw the rise of the digital world and the digital\neconomy as an enabler for reaching this goal of establishing the LEI as THE identifier for\norganizational identity. In addition to engaging with Certificate Authorities for leveraging LEIs in\ndigital certificates, this naturally led to engagement with those engaged in the blockchain/\ndistributed ledger technology world."),(0,a.kt)("p",null,"But the unequivocal value of the identity using the LEI is not apparent solely by evaluating the LEI for\nuse on a blockchain or distributed ledger. It is the intersection of the LEI with the Self Sovereign\nIdentity (SSI) world, adapting the concept of SSI that developed originally for natural persons for\norganizational digital identity purposes."),(0,a.kt)("p",null,"The SSI world immediately recognized and bought into the potential for digital organizational identity\nleveraging the LEI, stating that the impact that the verifiable LEI (vLEI) will have on adoption of SSI\ncannot be overestimated."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"What is a vLEI (verifiable LEI)?")),(0,a.kt)("p",null,"Verifiable Credentials are digitally signed credentials that are not only tamper-evident but capable of\nbeing cryptographically verified in a decentralized manner. vLEIs are based on the Trust over IP\nAuthentic Chained Data Container (ACDC) specification (",(0,a.kt)("a",{parentName:"p",href:"https://github.com/trustip/TSS0033-"},"https://github.com/trustip/TSS0033-"),"\ntechnology-stack-acdc), based on the Key Event Receipt Infrastructure protocol\n(",(0,a.kt)("a",{parentName:"p",href:"http://github.com/WebOfTrust/keri"},"http://github.com/WebOfTrust/keri")," - an Internet Engineering Task Force (IETF) draft specification),\nwhich is a more secure, enhanced variant of the W3C Verifiable Credential specification."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 3 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Figure 1")," : ",(0,a.kt)("strong",{parentName:"p"},"The LEI as a Verifiable Credential \u2013 the vLEI Trust Chain")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"vLEI Trust Chain")),(0,a.kt)("p",null,"To establish the vLEI Trust Chain, GLEIF will generate a Root Identifier to establish the Root of Trust.\nFurther, GLEIF will generate Delegated Identifiers to issue vLEI credentials."),(0,a.kt)("p",null,"GLEIF has developed 4 types of vLEI credentials:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Qualified vLEI Issuer vLEI Credential, issued by GLEIF to Qualified vLEI Issuers"),(0,a.kt)("li",{parentName:"ul"},"vLEI Legal Entity vLEI Credential, issued by Qualified vLEI Issuers to Legal Entities requesting a\nvLEI credential"),(0,a.kt)("li",{parentName:"ul"},"vLEI Role Credentials",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Legal Entity Official Organizational Role vLEI Credential, issued by Qualified vLEI\nIssuers to Persons whose ",(0,a.kt)("strong",{parentName:"li"},"Official Organizational Roles")," (ISO 5009 standard awaiting\npublication) that can be verified both by the Legal Entity as well as against one or\nmore public sources"),(0,a.kt)("li",{parentName:"ul"},"Legal Entity Engagement Context Role vLEI Credentials issued by Legal Entities, or by\na Qualified vLEI Issuer(s) as a value-added service to Legal Entities, to Persons in the\n",(0,a.kt)("strong",{parentName:"li"},"context of the engagement")," of those Persons with the Legal Entities which can be\nverified by the Legal Entity")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 4 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Figure 2 : The vLEI Ecosystem Chain of Trust and vLEI Credentials")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"What applications is GLEIF seeing for use of the vLEI?")),(0,a.kt)("p",null,"The vLEI will give government organizations, companies and other legal entities worldwide the\ncapacity to use the LEI\u2019s non-repudiable identification data in a growing number of digital business\nactivities, such as approving business transactions and contracts, onboarding customers, transacting\nwithin import/export and supply chain business networks and submitting regulatory filings and\nreports. GLEIF has seen confirmed demand for the vLEI from the pharmaceutical, healthcare,\ntelecom, financial services and automotive industries."),(0,a.kt)("p",null,"More information is included in the Press Release: ",(0,a.kt)("a",{parentName:"p",href:"https://www.gleif.org/en/newsroom/press-"},"https://www.gleif.org/en/newsroom/press-"),"\nreleases/gleif-advances-digital-trust-and-identity-for-legal-entities-globally"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"What is the vLEI Ecosystem Governance Framework?")),(0,a.kt)("p",null,"The engagement with the Self-Sovereign Identity (SSI) community led GLEIF to join the Trust over IP\nFoundation ",(0,a.kt)("em",{parentName:"p"},"(link to ToIP website),")," which GLEIF joined as a Contributor member. ToIP defines an\nInternet-scale solution using a \u2018dual stack\u2019 design for creating and maintaining trusted relationships\nbetween any two peers on the Internet: people, organizations and connected things."),(0,a.kt)("p",null,"In this design, the ToIP Technology Stack covers technical trust. The ToIP Governance Stack covers\nhuman trust which includes an Ecosystem Governance Framework which documents requirements at\nthe business, legal, and social layers. To the SSI experts engaged in ToIP, the LEI, as a key component\nin building a trust layer and technical infrastructure for identification and verification of legal entities,\nis the basis for a textbook example of being able to satisfy organizational identity requirements for\nany number of use cases or domains through the use of vLEIs."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 5 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"What makes GLEIF the \u2018root of trust\u2019 for the vLEI?")),(0,a.kt)("p",null,"Governance has been an important cornerstone of the Global LEI System and in the establishing\nGLEIF\u2019s role in operating and managing this system of LEIs. GLEIF is subject to oversight by global\nregulators and according to our statutes has established strong governance for the process of\nvalidating legal entities for LEI issuance and the maintenance and updating of legal entity reference\ndata."),(0,a.kt)("p",null,"Building on this strong governance which begins with the issuance and maintenance of the LEI itself,\nGLEIF will be the anchor of the vLEI ecosystem, at the root of the governance that will position the\nLEI as a key component in building a trust layer for identification and verification of legal entities as\nthe LEI allows authentication that the legal entity is indeed who it claims to be and that those who\nact on its behalf, can."),(0,a.kt)("p",null,"Also, see the related question in the Technical Question section below, \u2018 ",(0,a.kt)("strong",{parentName:"p"},"How will GLEIF be\nestablished as the root-of-trust for the vLEI ecosystem?\u2019")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"What digital identity issues can the vLEI solve?")),(0,a.kt)("p",null,"With the vLEI concept and infrastructure implementation goal, GLEIF has identified an important\nopportunity to help solve critical digital identity issues."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Commerce is based on trust between and among parties;"),(0,a.kt)("li",{parentName:"ul"},"Historically this has been done by persons getting to know each other and then doing\nresearch to be sure a company of organization is legitimate;"),(0,a.kt)("li",{parentName:"ul"},"Internet technology has never really completely solved this issue for digital\ncommerce. It is one of the areas that still allows hackers to operate.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Technical Questions regarding the vLEI Ecosystem Infrastructure")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"What does GLEIF see as important technical features that the technical solution for vLEI ecosystem\ninfrastructure must have?")),(0,a.kt)("p",null,"GLEIF think that the technical solution for vLEI ecosystem infrastructure must be interoperable and\nportable."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Open source/non-proprietary"),(0,a.kt)("li",{parentName:"ul"},"Interoperable"),(0,a.kt)("li",{parentName:"ul"},"Works with all technical solutions \u2013 blockchain/Distributed Ledger Technology (DLT)\nas well as cloud-based solutions")),(0,a.kt)("p",null,"Incorporating these features would allow the vLEI infrastructure to be able to be implemented as\npart of existing implementations/use cases using blockchain/DLT technology without the users\nneeding to abandon their existing technical solutions. The new approach also could accommodate\nexisting and new implementations not based on blockchain/DLT technology. GLEIF anticipates"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 6 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,"interfaces of the vLEI technical infrastructure to Hyperledger, Ethereum, Quorum and Corda based\nnetworks as well as cloud applications."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"What is KERI (Key Event Receipt Infrastructure)?")),(0,a.kt)("p",null,"Key Event Receipt Infrastructure (KERI) is a ledgerless approach to identity that enables a universal\ndecentralized key management infrastructure (DKMI). KERI takes the objectives that conventional\nPublic Key Infrastructure (PKI) tries to achieve with centralized, administrative roots of trust and\nachieves them with decentralized, cryptographic roots of trust. This solves many problems: security,\nprivacy, scalability, performance, cost, governance, and more. ",(0,a.kt)("em",{parentName:"p"},"(Link to KERI white paper: Smith, S.\nM., \u201cKey Event Receipt Infrastructure (KERI) Design\u201d, Revised 2020/09/06, 2019/07/03)")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"What Decentralized Identifier (DID) methods will the vLEI infrastructure use?")),(0,a.kt)("p",null,"There are two primary DID methods under active development that support KERI."),(0,a.kt)("p",null,"One is the did:keri method the other is the did:indy:\u201dledger\u201d:keri method. The first is a native did\nmethod that will be used by cloud Witnesses and Watchers (KERI roles are described below). The\nnative did:keri method provides a compatibility hook for DID Resolvers so that the DID resolver meta\ndata may be used to lookup the appropriate Witness service endpoints. The DID document may be\nminimally compliant as only the Resolver metadata is needed."),(0,a.kt)("p",null,"The second is a Hyperledger Indy specific network-of-networks DID method. In this new did:indy\nmethod, each Hyperledger Indy network gets its own method extension. Such as did:indy:sov and\ndid:indy:findy for example. In the case of KERI, an additional extension is added. For example,\ndid:indy:sov:keri is a special Hyperledger Indy method that provides DIDs on the Sovrin ledger but\nthat are based on KERI. This is called a KERI tunnel or KERI masquerade. The ledger in this case\nprovides discovery and storage but the root-of-trust is the associated Key Event Log (KEL) that is\nreferenced as an attribute on the associated Hyperledger Indy ledger. A DID Resolver would provide\nas metadata references to Witnesses with the appropriate KEL. A similar KERI tunnel is contemplated\nfor Ethereum and Bitcoin based KERI Witnesses and Watchers."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Click here for the link to the W3C DID standard.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"What are the roles in the KERI design?")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Controller"),"\nA Controller is a controlling entity of an identifier. At any point in time an identifier has at least one\nbut may have more than one controlling entity. Let L be the number of controlling entities. This set of\ncontrolling entities constitute the Controller. All proper key management events on the identifier\nmust include a signature from the sole controlling entity when there is only one member in the set of\ncontrolling entities or a least one signature from one of the controlling entities when there is more\nthan one. This signature may be expressed as a single collective signature when a collective signing\nscheme is used. Without loss of generality, when the context is unambiguous, the term Controller\nmay refer either to the whole set or a member of the set of controlling entities."),(0,a.kt)("p",null,"Typically, when there is more than one controlling entity, control is established via L signatures, one\nfrom each entity Controller. This is called multi-signature or multi-sig for short. Alternatively, with a K"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 7 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,"of L threshold control scheme, where K \u2264 L, control is established via any set of at least K signatures\neach one from a subset of at least size K of the L Controllers. A more sophisticated scheme may use\nfractional weighted multiple signatures. These multiple signatures under a threshold control scheme\nmay be expressed as a single collective threshold signature from an appropriate collective threshold\nsigning scheme. The description of the KERI protocol assumes the simplest case of individual not\ncollective signatures, but it is anticipated that the protocol may be extended to support collective\nmulti-signature schemes."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Verifier"),"\nA Verifier is an entity or component that cryptographically verifies the signature(s) on an event\nmessage. In order to verify a signature, a Verifier must first determine which set of keys are or were\nthe controlling set for an identifier when an event was issued. In other words, a Verifier must first\nestablish control authority for an identifier. For identifiers that are declared as non-transferable at\ninception this control establishment merely requires a copy of the inception event for the identifier.\nFor identifiers that are declared transferable at inception this control establishment requires a\ncomplete copy of the sequence of key operation events (inception and all rotations) for the identifier\nup to the time at which the statement was issued."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Validator"),"\nA Validator is an entity or component that determines that a given signed statement associated with\nan identifier was valid at the time of its issuance. Validation first requires that the statement is\nverifiable, that is, has a verifiable signature from the current controlling key-pair(s) at the time of its\nissuance. Therefore, a Validator must first act as a Verifier in order to establish the root authoritative\nset of keys. Once verified, the Validator may apply other criteria or constraints to the statement in\norder to determine its validity for a given use case. This use-case specific validation logic may be\nassociated with interaction event statements."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Witness"),"\nA Witness is an entity or component designated (trusted) by the Controller of an identifier. The\nprimary role of a Witness is to verify, sign, and keep events associated with an identifier. A witness is\nthe Controller of its own self-referential identifier which may or may not be the same as the\nidentifier to which it is a Witness. As a special case a Controller may serve as its own Witness.\nWitness designations are included in key (establishment) events. As a result, the role of a Witness\nmay be verified using the identifier\u2019s rotation history. When designated, a Witness becomes part of\nthe supporting infrastructure establishing and maintaining control authority over an identifier. An\nidentifier Witness therefore is part of its trust basis and may be controlled (but not necessarily so) by\nits Controller."),(0,a.kt)("p",null,"The purpose of a pool of Witnesses is to protect the Controller from external exploit of its identifier.\nA Witness may use the controlling key-pairs of its own self-referential identifier to create digital\nsignatures on event messages it has received but are associated with identifiers not necessarily\nunder its control. To clarify, a Witness controls its own self-referential identifier and acts as a witness\nof event messages for some identifier not necessarily under its control. A Witness may receive,\nverify, and store an event on an identifier. Verify means verify the signature attached to the event\nusing the current controlling key-pairs for the event at the time of event issuance."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 8 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,"Thus, a Witness first acts as an event Verifier. It determines current control authority of the event\u2019s\nidentifier with respect to the sequence of key (establishment) events it has so far received for that\nidentifier. The Witness follows a policy explained in more detail later for how it treats different\nversions of an event it may receive. Simply, it always gives priority to the first version of an event it\nreceives (first seen). The Witness signifies this by only signing and keeping the first successfully\nverified version of an event it receives. To restate, a Witness will never sign any other conflicting\nversion of the same event in an event sequence. The event sequence kept by a Witness for an\nidentifier must therefore be internally consistent."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Watcher"),"\nA Watcher is an entity or component that keeps a copy of a Key Event Receipt Log (KERL) for an\nidentifier but is not designated by the Controller thereof as one of its Witnesses. To clarify, a\nWatcher is not designated in the associated identifier\u2019s key events. A Watcher is the Controller of its\nown self-referential identifier which may not be the same as the identifier to which it is a Watcher.\nAn identifier Watcher may be part of the trust basis of a Validator and may also be controlled (but\nnot necessarily so) by the Validator\u2019s controlling entity. A Watcher may sign copies of its KERL or\nparts of its KERL but because a Watcher is not a designated Witness these are not witnessed receipts.\nThey may be considered Watcher receipts or ersatz receipts."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Juror"),"\nA Juror is an entity or component that performs duplicity detection on events and event receipts. A\nJuror is the Controller of its own self-referential identifier which may or may not be the same as the\nidentifier to which it is a Juror. The Juror may thereby create digital signatures on statements about\nduplicity it has detected."),(0,a.kt)("p",null,"A Juror detects duplicity by keeping a copy of any mutually inconsistent versions of any events its\nsees. It may then provide as proof of duplicity the set of mutually inconsistent versions of an event. A\nJuror uses the Key Event Receipt Log (KERL) or Key Event Log (KEL) from a Controller, Watcher, or\nWitness as the reference for comparison to determine duplicity. Duplicity takes two forms. In the\nfirst form, a Controller may be deemed duplicitous whenever it produces an event message that is\ninconsistent with another event message it previously produced. In the second form, a Witness may\nbe deemed duplicitous when it produces an event receipt that is inconsistent with another event\nreceipt it previously produced. The detailed rules for determining inconsistency are described later."),(0,a.kt)("p",null,"By construction, in this protocol, exploits of a Controller or its Witnesses exhibit themselves as\nduplicitous statements. Duplicity then becomes a basis for distrust in a Controller or its Witnesses. To\nsummarize, main role of a Juror is to provide duplicity detection of a Controller and/or its Witnesses\nto Validators so that a Validator may be protected from exploits of the Controller and/or its\nwitnesses. Duplicity is provable by any Juror to any Validator because the Validator may itself verify a\nset of inconsistent statements with respect to a KERL. Duplicity is therefore end-verifiable by any\nValidator at any time given inconsistent statements referenced to a KERL. In other words, a set of\nJurors may provide ambient duplicity protection to Validators. A Juror may be part of the trust basis\nof a Validator and may be under the control (but not necessarily so) of that Validator."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 9 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Judge"),"\nA Judge is an entity or component that examines the entries of one or more Key Event Receipt Logs\n(KERLs) and Duplicitous Event Logs (DELs) of a given identifier to validate that the event history is\nfrom a non-duplicitous Controller and has been witnessed by a sufficient number of non-duplicitous\nWitnesses such that it may be trusted or conversely not-trusted by a Validator."),(0,a.kt)("p",null,"In this sense, a Judge is a Validator of a Controller and its Witness pool. A Judge is the Controller of its\nown self-referential identifier which may or may not the same as the identifier to which it is a Judge.\nA Judge may thereby create digital signatures on statements about validations it has performed on\nKERLs and DELS. A Judge may obtain KERLS from one or more Witnesses or Watchers and may obtain\nDELs from one or more Jurors."),(0,a.kt)("p",null,"A Judge may be part of the trust basis of a Validator and may also be under the control of a Validator.\nA Judge may be a second party involved in a transaction with a first party Controller or a Judge may\nbe a trusted third party in a multi-party transaction that includes a Controller and other Validator\nparties. A given entity may act in multiple roles such as both Witness and Juror or both Juror and\nJudge. A Validator might perform its function by acting as all of a Watcher, Juror, and Judge or by\ntrusting other Witnesses, Watchers, Jurors and Judges."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Resolver"),"\nA Resolver is an entity or component that provides discovery for identifiers. A Resolver is the\nController of its own self-referential identifier which may not be the same as the identifier to which it\nis a Resolver. A Resolver primarily maps identifiers to the Uniform Resource Locators (URLs) or\nInternet Protocol (IP) addresses of components of the trust bases for identifiers. These components\ninclude Controllers, Witnesses, Watchers, Jurors and Judges. Given the URL or IP address of a\ncomponent, a user may there from obtain or be directed to the associated event histories (Key Event\nLogs (KELs), Key Event Receipt Logs (KERLs), and Duplicitous Event Logs (DELs)) in order that the user\nmay establish current (root) control authority for the identifier. The Resolver may cache these event\nhistories or key event subsequences as end verifiable proofs of root control authority. A Watcher\nmay act as a Resolver."),(0,a.kt)("p",null,"A Resolver provides a bootstrap discovery mechanism for KERI identifiers (AIDs). With respect to\nKERI, the target data for discovery is different for the two operative classes of identifier in KERI, that\nare, transferable and non-transferable identifier prefixes. In the case of a non-transferable identifier\nprefix, such as that of a Witness or Watcher, the target data may include a mapping from the non-\ntransferable identifier prefix to a service endpoint Uniform Resource Locator (URL) or directly to the\nInternet Protocol (IP) address of the Witness or Watcher KERL service. In this case, a Validator could\nquery the resultant IP address for a copy of the full KERL for the transferable identifier prefix to\nwhich the Witness or Watcher is entrained."),(0,a.kt)("p",null,"In the case of transferable identifiers, discovery may provide a mapping of the identifier prefix to a\ncached copy of either its full KEL or a copy of its inception event plus the latest rotation event or\nequivalently the latest key event state. From this copy, one may extract the identifier prefixes of the\ncurrent Witness set and then use discovery to access the KERLs for those Witnesses."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 10 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,"Because KELs and KERLs are end-verifiable, almost any method of internet discovery is viable for KERI\nbecause discovery is merely a bootstrap mechanism. The end-verification that happens post\ndiscovery ensures that the discovered material is securely attributed."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"How does KERI Key Management work?")),(0,a.kt)("p",null,"All ledger-based system security is based on signing keys not becoming compromised. The difference\nin KERI is that pre-rotated keys enable recovery of compromise of signing keys. And delegated\nidentifier keys may be recovered by any delegating identifiers. Multiple levels of delegation provide\nenhanced recovery. KERI\u2019s delegation is unique and is described as cooperative delegation. See the\nglossary below for a detailed summary of cooperative delegation. But the most important feature of\ncooperative delegation is the nested levels of delegation provide protection via recovery rotations of\nkey compromise both of signing keys and pre-rotated keys of the levels below."),(0,a.kt)("p",null,"Best practices for key management are assumed by any user of public-private key pairs. But like any\nkey management system one must protect one\u2019s secrets. KERI\u2019s pre-rotation makes those best\npractices all the more secure and nested delegation even more so. KERI specifically addresses the\nweakest link in conventional key management systems, that is key rotation. The pre-rotated keys\nnever need be exposed to side channel attacks against event signing infrastructure until they are\nactually used for a rotation. And pre-rotated are one-time-use rotation keys. This is a best practice\nand not subject to a host of side channel attacks that any from which non-one-time-use rotation keys\nmust be protected. The pre-rotated keys are also protected with a post-quantum proof hash thereby\nfuture proofing the system employed by KERI. Other key rotation algorithms that do not employ pre-\nrotation use much more complicated mechanisms for post-quantum proofing or not at all.\nMoreover, the nested delegation of identifiers that KERI employs enables enhanced security as the\ndelegated identifiers are protected by the keys of the delegating identifiers. This means that the root\nkeys need only be used once to delegate and never again unless the delegated keys become\ncompromised. With multiple levels of delegation this minimizes potential attacks on the root keys."),(0,a.kt)("p",null,"KERI key management provides multiple layers of threshold structures that serve to multiply the\nnumber of attack surfaces that must be simultaneously compromised for a successful exploit. These\nare pre-rotation, multi-sig, and nested delegation. Moreover, Witnesses and Watchers provide\nthreshold structures for protecting event signing and event signing verification. Unlike many other\nschemes that merely bolt on multi-signature support, KERI\u2019s support for multi-sig is built in as a first-\nclass citizen. With nested delegated design of the vLEI infrastructure, a successful attacker must\nsimultaneously compromise multiple nested multi-signatures on multiple sets of pre-rotated keys.\nIndeed, one may say that the vLEI infrastructure KERI implementation by GLEIF employs not just best\npractices for key management but best in class key management."),(0,a.kt)("p",null,"But to summarize, compromised pre-rotated keys on any but the root level the layer above may\nmerely perform a rotation to invalidate compromised pre-rotated keys. Given that the upper layers\nat least will be multi-sig, such a compromise would be extremely difficult and such compromises of\nmulti-sig systems are extremely rare. For example, so far there is no published case of a successful\nexploit of the Gnosis multi-sig wallet. And this does not even employ pre-rotation or multiple levels\nof delegation like KERI. So, KERI would be orders of magnitude more difficult to exploit. Such an\nexploit would be equivalent in difficulty to the compromise of the root keys for the most secure"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 11 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,"critical infrastructure. This is not at all equivalent to the compromise of a Domain Name Servers\n(DNS) certificate which is based on the well-known vulnerabilities in the outdated, flawed insecure\nDNS/CA (Certificate Authority) system."),(0,a.kt)("p",null,"In addition, as per the KERI architecture, any participant in the vLEI ecosystem will add\nreliability/availability by operating their own Watcher pools which will keep copies of the GLEIF Key\nEvent Logs (KELs). The following slide presentation provides diagrams of the notional witness\nnetwork:"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/SmithSamuelM/Papers/blob/master/presentations/GLEIF_with_KERI.web.pdf"},"https://github.com/SmithSamuelM/Papers/blob/master/presentations/GLEIF_with_KERI.web.pdf")),(0,a.kt)("p",null,"An even more extreme case would be a total compromise of all keys including the root pre-rotated\nkeys. In this case the root identifier must be abandoned, and a new root created. This is equivalent to\nthe total compromise of a ledger."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"More on the security implications of KERI")),(0,a.kt)("p",null,"The following white paper discusses in more detail the security implications of threshold structures\nand key management and root-of-trust with respect to KERI in a GLEIF class application:"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/SmithSamuelM/Papers/blob/master/whitepapers/IdentifierTheory_web.pdf"},"https://github.com/SmithSamuelM/Papers/blob/master/whitepapers/IdentifierTheory_web.pdf")),(0,a.kt)("p",null,"It is important to make apples to apples comparisons between key management schemes especially\nwith regards the root-of-trust. It is easy to confuse the security difference between a convenient\nscheme for the recovery of a weak root-of-trust and more inconvenient recovery scheme but for a\nmuch stronger root-of-trust. The latter may be magnitudes more secure than the former. The goal is\nto make compromise of the root-of-trust vanishingly remote as opposed to enabling the more\nconvenient but also more common recovery of a weak root-of-trust. The cumulative harm to the\nsystem is much greater for the weak root of trust as the cumulative harm grows the more one must\nrecover from exploit."),(0,a.kt)("p",null,"KERI enables a scalable distributed hierarchical dissemination of trust out to the leaves but with\nultimate recovery potential back to the extremely well protected root. Multi-level threshold\nstructures provide the strongest possible security mechanisms and may be designed to be arbitrarily\nsecure merely by multiplying the number of attack surfaces that must be simultaneously breached\nfor successful attack. KERI\u2019s hierarchical cooperative delegation enables convenient and scalable\nperformance at the outer levels without sacrificing ultimate security provided by increasingly higher\nlevels of security of the nested levels ending in the root level."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 12 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"How will GLEIF be established as the root-of-trust for the vLEI ecosystem?")),(0,a.kt)("p",null,"In order to understand how a hypothetically one would handle the compromise of keys, it is helpful\nto understand the original process by which the root-of-trust root Autonomic Identifier (AID) GLEIF ID\n(GID) is established."),(0,a.kt)("p",null,"The original root identifier GID becomes qualified after its creation by a multi-factor association with\nGLEIF as the controller. Once this multi-factor association is sufficiently published and recognized\nthat it becomes \u201ccommon knowledge\u201d. At which point the identifier (KERI AID = GID) may be used as\nthe recognized root-of-trust. The first action of this root of trust will be to delegate other identifiers\n(GIDs = KERI AIDs). The root level is only used for delegation and only allows rotations. This means\nthat each set of keys is a one-time use key set for a rotation that delegates. Each rotation commits to\na new set of pre-rotated keys that have never been exposed. Because the first rotation makes a set\nof delegations this root set may never need to be used again until such time as recovery or rotation\nof delegated keys is needed. Thus, the usage is minimized and be performed in the most secure\nmanner possible."),(0,a.kt)("p",null,"But suppose that somehow despite all these security measures, the root GID set of pre-rotated keys\nbecomes compromised (note this would be a multi-sig compromise of unused keys stored in\nseparate locations), then the original GID would have to be abandoned and a new GID would have to\nbe established via the same multi-factor association process as the original GID."),(0,a.kt)("p",null,"Recall, that any PKI scheme ultimately must perform such an abandonment and re-association if all\nkeys are compromised. What is unique about KERI is that by using threshold structures of multi-sig,\nnested delegation, and limiting exposure through one-time pre-rotated keys, the likelihood of such a\ncomplete compromise is as small as practically possible using current widely accepted digital\nsignature Public Key Infrastructure (PKI) libraries."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"How will the vLEI infrastructure handle revocation of credentials?")),(0,a.kt)("p",null,"GLEIF believes that revocation enforcement is one of the key differentiators to X.509 certificates.\nGLEIF\u2019s ToIP Ecosystem Governance Framework establishes a decentralized, hierarchical Public Key\nInfrastructure (PKI) with GLEIF being the root of trust for the associated vLEI ecosystem. Revocation\nis provided at each level of chained issued vLEI credentials. LEIs will be wrapped as Verifiable\nCredentials according to the ToIP Authentic Chained Data Container (ACDC) and associated Internet\nEngineering Task Force (IETF) standards. The ACDC specification is a more secure variant of the W3C\nVC standard. As an ACDC VC, the LEI will be cryptographically bound to the owner of the designated\nprivate/public key pair. Each vLEI will get a Decentralized Identifier (DID) assigned. Data will be\ndiscoverable via respective interfaces. vLEIs will support personal and organizational wallets and the\nrespective protocols. Having this said, governance of revocation does not only have technical but also\nbusiness implications. One could imagine that a vLEI gets revoked the moment the underlying LEI\nlapses. This would also help the LEI system and the reinforcement of renewals in order to achieve\nhigher data quality levels."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 13 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"What is the nested delegation that KERI uses?")),(0,a.kt)("p",null,"There are two types of delegation:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Delegated AIDs (Autonomic Identifiers (AIDs) which have associated Decentralized Identifier\n(DIDs). These are primary identifiers. Unless otherwise indicated, whenever the term\nidentifier is used with reference to KERI, the references are to primary identifiers."),(0,a.kt)("li",{parentName:"ul"},"Delegated Verifiable Credentials (VCs) aka a vLEI, in which an LEI code is an attribute of a\nvLEI. A LEI code is a secondary identifier.")),(0,a.kt)("p",null,"Delegated AIDs use cooperative delegation. Delegated VCs aka vLEIs do not use cooperative\ndelegation."),(0,a.kt)("p",null,"An ACDC VC (vLEI) is issued by a DID (derived from an AID) and issued to a DID (derived from an AID).\nThus a delegated vLEI issuance has an issuer and a holder. However, the DIDs for the issuer and\nholder of this delegated vLEI may or may not be related via a cooperative AID delegation."),(0,a.kt)("p",null,"Usually cooperative AIDs are based on some formal relationship such as employer-employee or other\naffiliation like GLEIF and its vLEI Issuers. The cooperation relationship imposes friction but with the\nreward of enhanced security."),(0,a.kt)("p",null,"Delegation of VC aka vLEIs are non-cooperative delegations. Thus, they could always be used to\nprovenance any vLEI and any data within the vLEI without imposing a cooperation relationship on the\ndelegation parties."),(0,a.kt)("p",null,"Nested delegation can store keys in a less secure manner but be protected by the delegator\u2019s key\nmanagement infrastructure. This allows higher performance by delegated infrastructure without\nsacrificing ultimate security. See the following for a more detailed discussion of the advantages of\nnested delegation:"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/SmithSamuelM/Papers/blob/master/whitepapers/IdentifierTheory_web.pdf"},"https://github.com/SmithSamuelM/Papers/blob/master/whitepapers/IdentifierTheory_web.pdf")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Glossary of Additional KERI Terms"),"\nA subset of KERI terms is provided below for convenience. A full description of all KERI terminology is\nbeyond the scope of this document but may be found in the KERI White Paper here:"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/SmithSamuelM/Papers/blob/master/whitepapers/KERI_WP.web.pdf"},"https://github.com/SmithSamuelM/Papers/blob/master/whitepapers/KERI_WP.web.pdf")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Duplicitous Event Log"),"\nA Duplicitous Event Log (DEL) is record of inconsistent event messages produced by a given\nController or Witness with respect to a given KERL. The duplicitous events are indexed to the\ncorresponding event in a KERL. A duplicitous event is represented by a set of two or more provably\nmutually inconsistent event messages with respect to a KERL. Each Juror keeps a DEL for each\nController and all designated Witnesses with respect to a KERL. Any Validator may confirm duplicity\nby examining a DEL."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 14 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Transferable (Non-transferable) Identifier"),"\nA Transferable (Non-transferable) Identifier allows (dis-allows) transfer of its control authority from\nthe current set of controlling keys to a new (next or ensuing) set via a rotation event (see below). An\nidentifier may be declared non-transferable at inception in its derivation code and/or in its inception\nevent (see below). Derivation code declaration is defined only for basic self-certifying identifiers. A\nrotation event (operation) on a transferable identifier may rotate to a null key thereby irreversibly\nconverting it into a Non-transferable Identifier. Once an identifier becomes non-transferable, no\nmore events are allowed for that identifier. The identifier is effectively abandoned from the\nstandpoint of KERI. By convention, when non-transferability of an identifier is declared in its\nderivation code then its authoritative (signing) key-pair may be converted to an encryption key-pair\nto enable a self-contained bootstrap to a secure communications channel using only the exchange of\nthe non-transferable identifier. Although a non-transferable identifier is abandoned from the\nstandpoint of KERI, it does not preclude a given application from employing the identifier. It is just\nthat no more events within KERI are allowed on the identifier (see event definition below). An\nidentifier declared at inception as non-transferable may have one and only one event, that is, the\ninception event. In this sense, a Non-transferable Identifier at inception is pre-abandoned. These\nidentifiers are typically meant to be used as ephemeral identifiers or identifiers where replacement\nof the identifier instead of key rotation is the preferred approach when the identifier becomes\ncompromised."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Cooperative Delegation"),"\nA delegation or identifier delegation operation is provided by a pair of events. One event is the\ndelegating event and the other event is the delegated event. This pairing of events is a somewhat\nnovel approach to delegation in that the resultant delegation requires cooperation between the\ndelegator and delegate. This is called Cooperative Delegation. In a Cooperative Delegation, a\ndelegating identifier performs an establishment operation (inception or rotation) on a delegated\nidentifier. A delegating event is a type of event that includes in its data payload an event seal of the\ndelegated event that is the target the delegation operation. This delegated event seal includes a\ndigest of the delegated event."),(0,a.kt)("p",null,"Figure: Delegating Event"),(0,a.kt)("p",null,"Figure: Delegated Event Seal"),(0,a.kt)("p",null,"Likewise, the targeted delegated event has a delegating event location seal that includes the unique\nlocation of the delegating event."),(0,a.kt)("p",null,"Figure: Delegated Event"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 15 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,"Figure: Delegating Event Location Seal"),(0,a.kt)("p",null,"The pair of seals cross-reference the two events participating in the cooperative delegation\noperation. In general, we may refer to both delegating and delegated event seals as delegation event\nseals or delegation seals. A delegation seal is either an event seal or an event location seal. The\ndelegating event seal is an event location seal and a delegated event seal is an event seal. The\ndelegated event seal in the delegating event provides an anchor to the delegated event. Likewise,\nthe delegating event location seal in the delegated event provides an anchor back to the delegating\nevent."),(0,a.kt)("p",null,"Because the delegating event payload is a list, a single delegating event may perform multiple\ndelegation operations, one per set of delegation seals."),(0,a.kt)("p",null,"Figure: Delegating Event Data"),(0,a.kt)("p",null,"Figure: Delegated Event Data"),(0,a.kt)("p",null,"A delegation operation directly delegates an establishment event, either an inception or rotation.\nThus, a delegation operation may either delegate an inception or delegate a rotation that\nrespectively may create and rotate the authoritative keys for delegated self-certifying identifier\nprefix."),(0,a.kt)("p",null,"The delegated identifier prefix is a type of self-addressing self-certifying prefix. This binds the\ndelegated identifier to its delegating identifier. The delegating identifier controller retains\nestablishment control authority over the delegated identifier in that the new delegated identifier\nmay only authorize non-establishment events with respect to itself. Delegation therefore authorizes\nsigning authority that can be revoked to some other self-certifying identifier. The delegated identifier\nmay have its own delegated key event sequence where the inception event is a delegated inception\nand any rotation events are delegated rotation events. Control authority for the delegated identifier\ntherefore requires verification of a given delegated establishment event which in turn requires\nverification of the delegating identifier\u2019s establishment event subsequence."),(0,a.kt)("p",null,"To reiterate, because the delegation seal in the data payload of the delegating event includes a\ndigest of the full delegated event, it thereby provides a forward cryptographic commitment to the\ndelegated identifier as well as any permissions and other configuration data in its associated event.\nThe delegation seal included in the delegated event provides a backward reference to the delegating"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 16 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,"event\u2019s unique location. This uniquely establishes which event in the delegating event log holds the\ncorresponding seal. This provides a type of cross reference that enables a verifier to look up the\ndelegating event and verify the existence of the delegation seal in the list of seals in that delegating\nevent and then verify that the event seal digest is a digest of the delegated event."),(0,a.kt)("p",null,"A common use case of delegation would be to delegate signing authority to a new identifier prefix.\nThe signing authority may be exercised by a sequence of signing keys that are able to be revoked\ndistinct from the keys used for the root identifier. This enables horizontal scalability of signing\noperations. The other major benefit of a cooperative delegation is that any exploiter that\ncompromises only the delegate\u2019s authoritative keys may not thereby capture control authority of the\ndelegate. A successful exploiter must also compromise the delegator\u2019s authoritative keys. Any exploit\nof the delegate is recoverable by the delegator. Conversely, merely compromising the delegator\u2019s\nsigning keys may not enable a delegated rotation without also compromising the delegates pre-\nrotated keys. Both sets of keys must be compromised simultaneously. This joint compromise\nrequirement is a distinctive security feature of cooperative delegation. Likewise as explained later,\nthis cooperative feature also enables recovery of a joint compromise of a delegation at any set of\ndelegation levels by a recovery at the next higher delegation level."),(0,a.kt)("p",null,"One reason to use rotations for delegation is for enhanced security. A rotation event is a first time\nuse of the pre-rotated keys to sign an event. The distinction between an interaction event rotating a\ndelegated identifier\u2019s keys and a rotation event rotating a delegated identifier\u2019s keys is that the latter\nenables nested recovery of a compromise of the delegate\u2019s keys, even its pre-rotated keys. A\nrotation event may be used to supersede an interaction event. When this happens the key event log\nforks at the superseding rotation event. With delegated events this means recovery is enabled even\nin the event of the joint compromise of a delegating identifier\u2019s signing keys and the delegated\nidentifiers pre-rotated keys. The delegating identifier merely needs to perform a rotation event that\nprovides a superseding rotation of the interaction event used to delegate a rotation of the delegate.\nThis superseding rotation also performs a superseding rotation of the delegates rotation. This nested\nrecovery may be applied to multiple levels of delegation. A rotation at the next higher level of\ndelegation may be used to recover from key compromise across any set of lower levels of delegation."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Seal"),"\nA seal is a cryptographic commitment in the form of a cryptographic digest or hash tree root (Merkle\nroot) that anchors arbitrary data or a tree of hashes of arbitrary data to a particular event in the key\nevent sequence. According to the dictionary, a seal provides evidence of authenticity. A key event\nsequence provides a verifiable proof of current control authority at the location of each event in the\nkey event sequence. In this sense therefore, a seal included in an event provides prove of current\ncontrol authority, i.e., authenticity of the data anchored at the location of the seal in the event\nsequence. A seal is an ordered self-describing data structure. Abstractly, this means each element of\nthe seal has a tag or label that describes the associated element\u2019s value. So far there are four\nnormative types of seals - these are digest, root, event, and location seals."),(0,a.kt)("p",null,"A digest seal includes a digest of external data. This minimal seal has an element whose label\nindicates that the value is a digest. The value is fully qualified Base64 with a prepended derivation\ncode that indicates the type of hash algorithm used to create the digest."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 17 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,"Figure: KERI Digest Seal"),(0,a.kt)("p",null,"A root seal provides the hash tree root of external data. This minimal seal has an element whose\nlabel indicates that the value is the root of a hash tree. The value is fully qualified Base64 with a\nprepended derivation code that indicates the type of hash algorithm used to create the hash root. In\norder to preclude second pre-image attacks, hash trees used for hash trees roots in KERI seals must\nbe sparse and of known depth similar to certificate transparency. One simple way to indicate depth is\nthat internal nodes in a sparse tree include a depth prefix that decrements with each level and must\nremain non-negative at a leaf."),(0,a.kt)("p",null,"Figure: KERI Root Seal"),(0,a.kt)("p",null,"An event seal includes the identifier prefix, sequence number, and digest of an event in a key event\nlog. The prefix, sequence number, and digest allow locating the event in an event log database. The\ndigest also allows confirmation of the anchored event contents. An event seal anchors one event to\nanother event. The two events may be either in the same key event sequence in two different key\nevent sequences with different identifier prefixes. Thus, a seal may provide a cryptographic\ncommitment to some key event from some other key event."),(0,a.kt)("p",null,"Figure: KERI Event Seal"),(0,a.kt)("p",null,"An event location seal is similar to an event seal. A location seal includes the prefix, sequence\nnumber, ilk and prior digest from an event. These four values together uniquely identify the location\nof an event in a Key Event Log. A location event is useful when two seals in two different events are\ncross-anchoring each other. This provides a cross reference of one event to another where the other\nevent\u2019s digest must include the seal in the event contents so it cannot contain the first event\u2019s digest\nbut the digest of the preceding event."),(0,a.kt)("p",null,"To clarify, digest creation means that only one of the cross anchors can include a complete digest of\nthe other event. The other cross anchor must use a unique subset of data such as the unique location\nof the event. The ",(0,a.kt)("em",{parentName:"p"},"ilk")," is required in the location because of the special case of recovery where a\nrotation event supersedes an interaction event. This is described in detail in the white paper under\nrecovery. Location seals are also useful in external data that is anchored to an event log. The location\nseal allows the external data to include a reference to the event that is anchoring the external data\u2019s\ncontents. Because the anchoring event includes a seal with the digest of the external data, it is\nanother form of cross anchor."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"vLEI Question and Answer Page 18 of 18\nPublic\nVersion 0.\n2022 - 02 - 07\n")),(0,a.kt)("p",null,"Figure: KERI Event Location Seal"),(0,a.kt)("p",null,"The data structure that provides the elements of a seal must have a canonical order so that it may be\nreproduced in a digest of elements of an event. Different types of serialization encodings may\nprovide different types of ordered mapping data structures. One universal canonical ordering data\nstructure is a list of lists (array or arrays) of (label, value) pairs. The order of appearance in each list of\neach (label, value) pair is standardized and may be used to produce a serialization of the associated\nvalues."),(0,a.kt)("p",null,"The interpretation of the data associated with the digest or hash tree root in the seal is independent\nof KERI. This allows KERI to be agnostic about anchored data semantics. Another way of saying this is\nthat seals are data agnostic; they do not care about the semantics of the associated data. This better\npreserve privacy because the seal itself does not leak any information about the purpose or specific\ncontent of the associated data. Furthermore, because digests are a type of content address, they are\nself-discoverable. This means there is no need to provide any sort of context or content specific tag\nor label for the digests. Applications that use KERI may provide discovery of a digest via a hash table\n(mapping) whose indexes (hash keys) are the digests and the values in the table are the location of\nthe digest in a specific event. To restate, the semantics of the digested data are not needed for\ndiscovery of the digest within a key event sequence."),(0,a.kt)("p",null,"To elaborate, the provider of the data understands the purpose and semantics and may disclose\nthose as necessary, but the act of verifying authoritative control does not depend on the data\nsemantics, merely the inclusion of the seal in an event. It is up to the provider of the data to declare\nor disclose the semantics when used in an application. This may happen independently of verifying\nthe authenticity of the data via the seal. This declaration may be provided by some external\nApplication Program Interface (API) that uses KERI. In this way, KERI provides support to applications\nthat satisfies the spanning layer maxim of minimally sufficient means. Seals merely provide evidence\nof authenticity of the associated (anchored) data whatever that may be."),(0,a.kt)("p",null,"This approach follows the design principle of context independent extensibility. Because the seals are\ncontext agnostic, the context is external to KERI. Therefore, the context extensibility is external to,\nand hence, independent of KERI. This is in contrast to context dependent extensibility or even\nindependently extensible contexts that use extensible context mechanisms such as linked data or tag\nregistries. Context independent extensibility means that KERI itself is not a locus of coordination\nbetween contexts for anchored data. This maximizes decentralization and portability."),(0,a.kt)("p",null,"Extensibility is provided instead at the application layer above KERI though context specific external\nAPIs that reference KERI seals in order to establish control authority, and hence, authenticity of the\nanchored (digested) data. Each API provides the context, not KERI. This means that interoperability\nwithin KERI is focused solely on interoperability of control establishment. But that interoperability is\ntotal and complete and is not dependent on anchored data context."))}u.isMDXComponent=!0}}]);