#!/usr/bin/env node

/**
 * Generates an explicit sidebars file from the docs directory structure
 * for use by osodevops/docusaurus-llm-docs which cannot handle
 * Docusaurus autogenerated sidebars.
 *
 * Usage: node scripts/generate-sidebar-for-llm.js [docs-dir] [output-path]
 */

const fs = require('fs');
const path = require('path');

const docsDir = process.argv[2] || path.join(__dirname, '..', 'docs');
const outputPath = process.argv[3] || path.join(__dirname, '..', 'sidebars-resolved.js');

function getCategoryConfig(dirPath) {
  const configPath = path.join(dirPath, '_category_.json');
  if (fs.existsSync(configPath)) {
    try {
      return JSON.parse(fs.readFileSync(configPath, 'utf8'));
    } catch {
      return null;
    }
  }
  return null;
}

function getDocId(filePath, baseDir) {
  const rel = path.relative(baseDir, filePath);
  // Remove extension and convert to forward slashes (Docusaurus doc ID format)
  return rel.replace(/\.(mdx?|html)$/, '').replace(/\\/g, '/');
}

function isDocFile(filename) {
  return /\.(md|mdx)$/.test(filename) && !filename.startsWith('_');
}

function scanDirectory(dirPath, baseDir) {
  const entries = fs.readdirSync(dirPath, { withFileTypes: true });
  const items = [];

  // Collect doc files at this level
  const docFiles = entries
    .filter(e => e.isFile() && isDocFile(e.name))
    .sort((a, b) => a.name.localeCompare(b.name));

  for (const file of docFiles) {
    items.push(getDocId(path.join(dirPath, file.name), baseDir));
  }

  // Collect subdirectories
  const dirs = entries
    .filter(e => e.isDirectory() && !e.name.startsWith('_') && e.name !== 'node_modules')
    .sort((a, b) => a.name.localeCompare(b.name));

  for (const dir of dirs) {
    const subPath = path.join(dirPath, dir.name);
    const config = getCategoryConfig(subPath);
    const subItems = scanDirectory(subPath, baseDir);

    if (subItems.length > 0) {
      const category = {
        type: 'category',
        label: (config && config.label) || dir.name.replace(/^\d+_?/, '').replace(/-/g, ' '),
      };
      if (config && config.position != null) {
        category.position = config.position;
      }
      category.items = subItems;
      items.push(category);
    }
  }

  return items;
}

// Also scan directories with underscore prefix that contain _category_.json
// (Docusaurus includes these if they have category config)
function scanWithUnderscoreDirs(dirPath, baseDir) {
  const entries = fs.readdirSync(dirPath, { withFileTypes: true });
  const items = [];

  // Doc files at this level (non-underscore prefixed)
  const docFiles = entries
    .filter(e => e.isFile() && isDocFile(e.name))
    .sort((a, b) => a.name.localeCompare(b.name));

  for (const file of docFiles) {
    items.push(getDocId(path.join(dirPath, file.name), baseDir));
  }

  // All subdirectories that either don't start with _ OR have a _category_.json
  const dirs = entries
    .filter(e => {
      if (!e.isDirectory() || e.name === 'node_modules') return false;
      if (!e.name.startsWith('_')) return true;
      // Include underscore-prefixed dirs if they have a _category_.json
      return fs.existsSync(path.join(dirPath, e.name, '_category_.json'));
    })
    .sort((a, b) => {
      // Sort by position from _category_.json if available, then by name
      const configA = getCategoryConfig(path.join(dirPath, a.name));
      const configB = getCategoryConfig(path.join(dirPath, b.name));
      const posA = (configA && configA.position != null) ? configA.position : 9999;
      const posB = (configB && configB.position != null) ? configB.position : 9999;
      if (posA !== posB) return posA - posB;
      return a.name.localeCompare(b.name);
    });

  for (const dir of dirs) {
    const subPath = path.join(dirPath, dir.name);
    const config = getCategoryConfig(subPath);
    const subItems = scanWithUnderscoreDirs(subPath, baseDir);

    if (subItems.length > 0) {
      const label = (config && config.label) || dir.name.replace(/^_?\d+_?/, '').replace(/-/g, ' ');
      items.push({
        type: 'category',
        label: label,
        items: subItems,
      });
    }
  }

  return items;
}

const resolvedItems = scanWithUnderscoreDirs(docsDir, docsDir);

const output = `// Auto-generated resolved sidebar for LLM docs generation
// Generated by scripts/generate-sidebar-for-llm.js
// Do not edit manually

/** @type {import('@docusaurus/plugin-content-docs').SidebarsConfig} */
const sidebars = {
  tutorialSidebar: ${JSON.stringify(resolvedItems, null, 2)},
};

module.exports = sidebars;
`;

fs.writeFileSync(outputPath, output, 'utf8');

const countItems = (items) => items.reduce((acc, item) => {
  if (typeof item === 'string') return acc + 1;
  if (item.items) return acc + countItems(item.items);
  return acc;
}, 0);

const totalDocs = countItems(resolvedItems);
const totalCategories = resolvedItems.filter(i => typeof i !== 'string').length;

console.log(`Generated resolved sidebar: ${totalDocs} docs, ${totalCategories} top-level categories`);
console.log(`Output: ${outputPath}`);
